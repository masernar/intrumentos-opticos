import numpy as np
import matplotlib.pyplot as plt
from PIL import Image

# --- 0. Configuración de Precisión ---
dtype_complejo = np.complex128

print("Iniciando simulación de microscopio 4f (Punto 2)...")
print("Usando Test de Estrella (Siemens Star) sintético.")
print("-" * 30)

# --- 1. Parámetros Físicos (Unidades en mm) ---
LAMBDA = 533e-6   # 533 nm convertidos a milímetros
NA = 0.5         # Apertura Numérica del objetivo
M_OBJETIVO = 20.0  # Aumento del objetivo
F_TL = 200.0       # Distancia focal Lente Tubo (mm)

# Parámetros deducidos
F_MO = F_TL / M_OBJETIVO
R_PUPILA = NA * F_MO

# --- ¡CORRECCIÓN! Calculamos r_abbe aquí ---
r_abbe = (LAMBDA * 1000) / (2 * NA)  # 0.533 µm

print(f"Parámetros: λ={LAMBDA*1000:.0f}nm, f_MO={F_MO:.1f}mm, R_Pupila={R_PUPILA:.1f}mm")
print(f"Límite de Abbe teórico (r = λ/2NA): {r_abbe:.3f} µm")

# --- 2. Malla de Simulación (Plano Pupila P(x,y)) ---
N = 1024  # Número de píxeles (Resolución de la simulación). 1024x1024
L_PUPILA = 20.0  # Ancho total de la "ventana" de simulación (mm)
dx = L_PUPILA / N # Tamaño de píxel en plano pupila (mm)
eje_x = np.linspace(-L_PUPILA/2, L_PUPILA/2 - dx, N)
X, Y = np.meshgrid(eje_x, eje_x)

# --- 3. Malla y Objeto (Plano Objeto S(ξ,η)) ---
# Escala del plano objeto (conjugado de Fourier)
d_xi = (LAMBDA * F_MO) / L_PUPILA
d_xi_micras = d_xi * 1000  # Convertir a micras (µm)
print(f"Tamaño píxel ENTRADA (Δξ): {d_xi_micras:.3f} µm/píxel")

L_OBJETO_MICRAS = d_xi_micras * N
eje_xi_micras = np.linspace(-L_OBJETO_MICRAS/2, L_OBJETO_MICRAS/2 - d_xi_micras, N)

# CÁLCULO DE EJES DE SALIDA (Magnificación)
d_u = (LAMBDA * F_TL) / L_PUPILA
d_u_micras = d_u * 1000
print(f"Tamaño píxel SALIDA (Δu): {d_u_micras:.3f} µm/píxel (Magnificación de {d_u/d_xi:.0f}x)")

L_IMAGEN_MICRAS = d_u_micras * N
eje_u_micras = np.linspace(-L_IMAGEN_MICRAS/2, L_IMAGEN_MICRAS/2 - d_u_micras, N)


# --- Creación del Objeto S(ξ, η) [Test de Estrella] ---
print(f"Creando objeto 'Test de Estrella' sintético...")
S_muestra = np.zeros((N, N), dtype=dtype_complejo)
N_cuñas = 256 # Número total de cuñas (128 blancas, 128 negras)

# Creamos coordenadas relativas al centro (en píxeles)
eje_pix = np.linspace(-N/2, N/2 - 1, N)
X_pix, Y_pix = np.meshgrid(eje_pix, eje_pix)

# Convertimos a coordenadas polares
angulo = np.arctan2(Y_pix, X_pix) # Ángulo (-pi a +pi)
radio_pix = np.sqrt(X_pix**2 + Y_pix**2) # Radio (en píxeles)

# Usamos una función Seno en el ángulo para crear las cuñas
cuñas = (np.sin(N_cuñas / 2 * angulo) > 0).astype(float)
S_muestra = cuñas.astype(dtype_complejo)

# Ponemos un fondo gris fuera de la estrella (opcional)
radio_max_micras = L_OBJETO_MICRAS / 2.5
radio_max_pix = radio_max_micras / d_xi_micras
S_muestra[radio_pix > radio_max_pix] = 0.5 # Fondo gris
print(f"Objeto 'Test de Estrella' con {N_cuñas} cuñas creado.")


# --- 4. Creación de la Función Pupila P(x,y) ---
R = np.sqrt(X**2 + Y**2)
P_pupila = np.zeros((N, N), dtype=dtype_complejo)
P_pupila[R <= R_PUPILA] = 1.0 + 0.0j

# --- 5. Simulación 4f (La Doble Transformada) ---
print("Ejecutando modelo 4f: FFT(P * FFT(S))...")

def tf_optica(campo):
    # Esta función usa fft2 (Transformada Directa)
    return np.fft.fftshift(np.fft.fft2(np.fft.ifftshift(campo)))

# Etapa 1: Objeto -> Pupila (TF 1)
U_pupila = tf_optica(S_muestra)

# Etapa 2: Filtrado en la Pupila (multiplicación)
U_pupila_filtrada = U_pupila * P_pupila

# Etapa 3: Pupila -> Imagen (TF 2)
# La segunda lente también hace una Transformada DIRECTA (fft)
U_imagen = tf_optica(U_pupila_filtrada)

# Etapa 4: Detección en la Cámara (Intensidad)
I_imagen_simulada = np.abs(U_imagen)**2

if np.max(I_imagen_simulada) > 0:
    I_imagen_simulada /= np.max(I_imagen_simulada)

print("¡Simulación completada!")

# --- 6. Visualización y Análisis (Gráficos Separados) ---
# (El cálculo de r_abbe ya se hizo en el Paso 1)
print(f"\nAnálisis: Comparar radio de confusión con límite de Abbe.")

# --- Gráfico 1: Objeto de Entrada ---
fig1, ax1 = plt.subplots(figsize=(8, 7))
# Capturamos la imagen en la variable 'im1'
im1 = ax1.imshow(np.abs(S_muestra), cmap='gray',
           extent=[eje_xi_micras.min(), eje_xi_micras.max(), eje_xi_micras.min(), eje_xi_micras.max()])
ax1.set_title(f'Objeto de Entrada S(ξ, η)')
ax1.set_xlabel(f'ξ (µm)')
ax1.set_ylabel('η (µm)')
# Añadimos la barra de color, usando la info de 'im1'
fig1.colorbar(im1, ax=ax1, label='Intensidad')
print("Mostrando Gráfico 1: Objeto de Entrada...")


# --- Gráfico 2: Pupila P(x, y) ---
fig2, ax2 = plt.subplots(figsize=(8, 7))
im2 = ax2.imshow(np.abs(P_pupila), cmap='gray',
           extent=[eje_x.min(), eje_x.max(), eje_x.min(), eje_x.max()])
ax2.set_title(f'Pupila P(x, y) (NA = {NA})')
ax2.set_xlabel('x (mm)')
ax2.set_ylabel('y (mm)')
# Añadimos la barra de color (0 = opaco, 1 = transparente)
fig2.colorbar(im2, ax=ax2, label='Transmitancia')
print("Mostrando Gráfico 2: Pupila...")


# --- Gráfico 3: Imagen Simulada ---
fig3, ax3 = plt.subplots(figsize=(8, 7))
im3 = ax3.imshow(I_imagen_simulada, cmap='gray',
           extent=[eje_u_micras.min(), eje_u_micras.max(), eje_u_micras.min(), eje_u_micras.max()])
ax3.set_title('Imagen Simulada |U_img|²')
ax3.set_xlabel(f'u (µm)')
ax3.set_ylabel('v (µm)')
# Añadimos la barra de color (Intensidad normalizada)
fig3.colorbar(im3, ax=ax3, label='Intensidad')
print("Mostrando Gráfico 3: Imagen Simulada...")


# --- Comando final para mostrar todas las ventanas ---
print("Ejecución finalizada. Mostrando todas las gráficas.")
plt.show()